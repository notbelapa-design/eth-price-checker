<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ETH Price Checker</title>
  <!-- Chart.js for the price chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  <!-- Canvas Confetti for celebration when price exceeds threshold -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', Arial, Helvetica, sans-serif;
      color: #fff;
      min-height: 100vh;
      background-color: #050b22;
      overflow-x: hidden;
      position: relative;
      transition: background 2s;
    }
    /* Happy state rainbow gradient background */
    body.happy {
      background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0, #7f00ff, #e100ff);
      background-size: 600% 600%;
      animation: gradientMove 10s ease infinite;
    }
    @keyframes gradientMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    /* Matrix canvas behind everything */
    #matrix-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -2;
      pointer-events: none;
    }
    /* Container to center content and provide symmetry */
    #container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 1;
      position: relative;
    }
    #top {
      text-align: center;
      margin-bottom: 2rem;
    }
    #emoji {
      font-size: 5rem;
      margin-bottom: 0.5rem;
    }
    #header {
      margin: 0;
      font-size: 2rem;
    }
    #price {
      font-size: 1.1rem;
      margin-top: 0.3rem;
    }
    #middle {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    /* Left message styling with slight glitch effect using layered shadows */
    #left-message {
      flex: 1;
      margin-right: 1rem;
      font-size: 2rem;
      line-height: 1.3;
      max-width: 50%;
      text-transform: uppercase;
      position: relative;
    }
    #left-message::after,
    #left-message::before {
      content: attr(data-text);
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      overflow: hidden;
      mix-blend-mode: difference;
      opacity: 0.7;
      pointer-events: none;
    }
    /* Slight color offsets for glitch layers */
    #left-message::before {
      text-shadow: -2px 0 red;
      animation: glitchShift1 2s infinite linear alternate-reverse;
    }
    #left-message::after {
      text-shadow: 2px 0 cyan;
      animation: glitchShift2 3s infinite linear alternate-reverse;
    }
    @keyframes glitchShift1 {
      0% { transform: translate(0px, 0px); }
      20% { transform: translate(-2px, -1px); }
      40% { transform: translate(2px, 1px); }
      60% { transform: translate(-1px, 2px); }
      80% { transform: translate(1px, -2px); }
      100% { transform: translate(0px, 0px); }
    }
    @keyframes glitchShift2 {
      0% { transform: translate(0px, 0px); }
      25% { transform: translate(1px, -2px); }
      50% { transform: translate(-1px, 2px); }
      75% { transform: translate(2px, 1px); }
      100% { transform: translate(0px, 0px); }
    }
    /* Wordle board on right */
    #wordle {
      flex: 1;
      max-width: 50%;
      display: grid;
      grid-template-rows: repeat(6, auto);
      gap: 0.4rem;
      justify-content: center;
    }
    .wordle-row {
      display: flex;
      gap: 0.4rem;
      justify-content: center;
    }
    .wordle-tile {
      width: 3rem;
      height: 3rem;
      border: 2px solid #555;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      text-transform: uppercase;
      background: rgba(255,255,255,0.05);
      color: #eee;
    }
    /* Chart container styling */
    #chart-container {
      width: 100%;
      max-width: 900px;
      margin-top: 1rem;
      display: none;
    }
  </style>
</head>
<body>
<canvas id="matrix-canvas"></canvas>
<div id="container">
  <div id="top">
    <div id="emoji"></div>
    <h1 id="header">Checking ETH price...</h1>
    <p id="price"></p>
  </div>
  <div id="middle">
    <div id="left-message" data-text=""></div>
    <div id="wordle"></div>
  </div>
  <div id="chart-container">
    <canvas id="chart"></canvas>
  </div>
</div>
<!-- Canvas for confetti; hidden until triggered -->
<canvas id="confetti-canvas"></canvas>
<script>
const happyThreshold = 4000; // price threshold for happy state

// Fetch current ETH price
async function fetchPrice() {
  const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
  const data = await resp.json();
  return data.ethereum.usd;
}

// Fetch historical prices for chart (7 days)
async function fetchChartData() {
  const resp = await fetch('https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=7&interval=daily');
  const data = await resp.json();
  return data.prices;
}

let chart; // Chart.js instance

async function drawChart(prices) {
  const ctx = document.getElementById('chart').getContext('2d');
  const labels = prices.map(p => {
    const d = new Date(p[0]);
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  });
  const priceData = prices.map(p => Math.round(p[1] * 100) / 100);
  const thresholdData = labels.map(() => happyThreshold);
  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'ETH Price (USD)',
          data: priceData,
          borderColor: 'orange',
          backgroundColor: 'rgba(255,165,0,0.2)',
          tension: 0.3,
        },
        {
          label: 'Threshold ($4000)',
          data: thresholdData,
          borderColor: 'red',
          borderDash: [5, 5],
          fill: false,
        },
      ],
    },
    options: {
      scales: {
        y: {
          beginAtZero: false,
          ticks: {
            color: getComputedStyle(document.body).color,
          },
        },
        x: {
          ticks: {
            color: getComputedStyle(document.body).color,
          },
        },
      },
      plugins: {
        legend: {
          labels: {
            color: getComputedStyle(document.body).color,
          },
        },
      },
    },
  });
}

function updateChartColors() {
  if (chart) {
    const color = getComputedStyle(document.body).color;
    chart.options.plugins.legend.labels.color = color;
    chart.options.scales.x.ticks.color = color;
    chart.options.scales.y.ticks.color = color;
    chart.update();
  }
}

// Update page based on current price
async function updatePage() {
  const price = await fetchPrice();
  document.getElementById('price').textContent = 'Current price: $' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  const emojiEl = document.getElementById('emoji');
  const headerEl = document.getElementById('header');
  if (price >= happyThreshold) {
    emojiEl.textContent = 'ðŸ¥³';
    headerEl.textContent = 'ETH is above $4,000!';
    document.body.classList.add('happy');
    launchConfetti();
  } else {
    emojiEl.textContent = 'ðŸ˜¢';
    headerEl.textContent = 'ETH is below $4,000';
    document.body.classList.remove('happy');
  }
  updateChartColors();
}

// Launch confetti when price is above threshold
function launchConfetti() {
  const myConfetti = confetti.create(document.getElementById('confetti-canvas'), { resize: true, useWorker: true });
  myConfetti({
    particleCount: 200,
    spread: 90,
    origin: { y: 0.6 },
  });
}

// Initialize page
async function init() {
  const prices = await fetchChartData();
  drawChart(prices);
  document.getElementById('chart-container').style.display = 'block';
  updatePage();
}
init();
// Refresh price every minute
setInterval(updatePage, 60000);

// Set the left-side message (CRUU style)
const leftMessage = `THIS IS WHAT YOU WANTED RIGHT<br>BUT YOU'RE NOT HERE YET<br>SO WHAT HAPPENS<br>WHEN IT HITS 4K<br>SOMETHING MAGICAL`;
const leftEl = document.getElementById('left-message');
// inject HTML with breaks for the visual layout
leftEl.innerHTML = leftMessage;
// also set the data-text attribute used by glitch layers (remove <br> tags)
leftEl.setAttribute('data-text', leftMessage.replace(/<br>/g, ' '));

// Build Wordle board
const wordleContainer = document.getElementById('wordle');
for (let r = 0; r < 6; r++) {
  const rowDiv = document.createElement('div');
  rowDiv.className = 'wordle-row';
  for (let c = 0; c < 5; c++) {
    const tile = document.createElement('div');
    tile.className = 'wordle-tile';
    rowDiv.appendChild(tile);
  }
  wordleContainer.appendChild(rowDiv);
}

// Wordle game logic
const targetWord = 'HAVEN';
let currentRow = 0;
let currentTile = 0;
const guesses = Array(6).fill('');
document.addEventListener('keydown', function(event) {
  const rows = wordleContainer.children;
  if (event.key === 'Backspace') {
    if (currentTile > 0) {
      currentTile--;
      guesses[currentRow] = guesses[currentRow].slice(0, -1);
      const tile = rows[currentRow].children[currentTile];
      tile.textContent = '';
      tile.style = '';
    }
  } else if (event.key === 'Enter') {
    if (currentTile === 5) {
      evaluateGuess();
    }
  } else if (/^[a-zA-Z]$/.test(event.key)) {
    if (currentTile < 5) {
      const letter = event.key.toUpperCase();
      guesses[currentRow] += letter;
      const tile = rows[currentRow].children[currentTile];
      tile.textContent = letter;
      currentTile++;
    }
  }
});

function evaluateGuess() {
  const guess = guesses[currentRow];
  const rowTiles = wordleContainer.children[currentRow].children;
  // Count letters in target word
  const letterCount = {};
  for (const ch of targetWord) {
    letterCount[ch] = (letterCount[ch] || 0) + 1;
  }
  const statuses = Array(5).fill('absent');
  // First pass: correct positions
  for (let i = 0; i < 5; i++) {
    if (guess[i] === targetWord[i]) {
      statuses[i] = 'correct';
      letterCount[guess[i]]--;
    }
  }
  // Second pass: present letters
  for (let i = 0; i < 5; i++) {
    if (statuses[i] !== 'correct' && targetWord.includes(guess[i]) && letterCount[guess[i]] > 0) {
      statuses[i] = 'present';
      letterCount[guess[i]]--;
    }
  }
  // Apply colors based on statuses
  for (let i = 0; i < 5; i++) {
    const tile = rowTiles[i];
    if (statuses[i] === 'correct') {
      tile.style.background = '#538d4e';
      tile.style.borderColor = '#538d4e';
      tile.style.color = '#fff';
    } else if (statuses[i] === 'present') {
      tile.style.background = '#b59f3b';
      tile.style.borderColor = '#b59f3b';
      tile.style.color = '#fff';
    } else {
      tile.style.background = '#3a3a3c';
      tile.style.borderColor = '#3a3a3c';
      tile.style.color = '#fff';
    }
  }
  if (guess === targetWord) {
    setTimeout(() => alert('Congratulations! You guessed the word!'), 100);
    document.removeEventListener('keydown', arguments.callee);
  } else {
    currentRow++;
    currentTile = 0;
    if (currentRow >= 6) {
      setTimeout(() => alert('Game over! The word was ' + targetWord), 100);
      document.removeEventListener('keydown', arguments.callee);
    }
  }
}

// Start the matrix background effect
startMatrixRain();

// Matrix rain effect for cryptic background
function startMatrixRain() {
  const canvas = document.getElementById('matrix-canvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);
  const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  const fontSize = 16;
  let columns = Math.floor(canvas.width / fontSize);
  // initialize drops array representing y position for each column
  let drops = new Array(columns).fill(1);
  function draw() {
    if (canvas.width !== window.innerWidth || canvas.height !== window.innerHeight) {
      resizeCanvas();
      columns = Math.floor(canvas.width / fontSize);
      drops = new Array(columns).fill(1);
    }
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#0F0';
    ctx.font = fontSize + 'px monospace';
    for (let i = 0; i < drops.length; i++) {
      const text = letters.charAt(Math.floor(Math.random() * letters.length));
      ctx.fillText(text, i * fontSize, drops[i] * fontSize);
      if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
        drops[i] = 0;
      }
      drops[i]++;
    }
  }
  setInterval(draw, 50);
}
</script>
</body>
</html>
