<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ETH Price Checker</title>
  <!-- Chart.js for the price chart -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>
  <!-- Canvas Confetti for celebration when price exceeds threshold -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, Helvetica, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
      background-color: #050b22;
      color: #fff;
      transition: background 2s;
    }
    /* Happy state rainbow gradient background */
    body.happy {
      background: linear-gradient(45deg, #ff0080, #ff8c00, #40e0d0, #7f00ff, #e100ff);
      background-size: 600% 600%;
      animation: gradientMove 10s ease infinite;
    }
    @keyframes gradientMove {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    #emoji {
      font-size: 6rem;
      margin-top: 2rem;
    }
    h1 {
      margin: 0;
      margin-top: 1rem;
      font-size: 2rem;
    }
    #price {
      font-size: 1.2rem;
      margin-top: 0.5rem;
    }
    #chart-container {
      width: 80%;
      max-width: 600px;
      margin-top: 1rem;
      display: none;
    }
    /* Left side message */
    #left-message {
      position: absolute;
      left: 2rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 2rem;
      line-height: 1.2;
      max-width: 40%;
      pointer-events: none;
    }
    /* Wordle board on the right */
    #wordle {
      position: absolute;
      right: 2rem;
      top: 50%;
      transform: translateY(-50%);
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      gap: 0.3rem;
    }
    .wordle-row {
      display: flex;
      gap: 0.3rem;
    }
    .wordle-tile {
      width: 3rem;
      height: 3rem;
      border: 2px solid #777;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      font-weight: bold;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
<div id="emoji"></div>
<h1 id="header">Checking ETH price...</h1>
<p id="price"></p>
<div id="chart-container">
  <canvas id="chart"></canvas>
</div>
<div id="left-message"></div>
<div id="wordle"></div>
<!-- Canvas for confetti; hidden until triggered -->
<canvas id="confetti-canvas"></canvas>
<script>
const happyThreshold = 4000; // price threshold for happy state

// Fetch current ETH price
async function fetchPrice() {
  const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
  const data = await resp.json();
  return data.ethereum.usd;
}

// Fetch historical prices for chart (7 days)
async function fetchChartData() {
  const resp = await fetch('https://api.coingecko.com/api/v3/coins/ethereum/market_chart?vs_currency=usd&days=7&interval=daily');
  const data = await resp.json();
  return data.prices;
}

let chart; // Chart.js instance

async function drawChart(prices) {
  const ctx = document.getElementById('chart').getContext('2d');
  const labels = prices.map(p => {
    const d = new Date(p[0]);
    return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  });
  const priceData = prices.map(p => Math.round(p[1] * 100) / 100);
  const thresholdData = labels.map(() => happyThreshold);
  if (chart) chart.destroy();
  chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: labels,
      datasets: [
        {
          label: 'ETH Price (USD)',
          data: priceData,
          borderColor: 'orange',
          backgroundColor: 'rgba(255,165,0,0.2)',
          tension: 0.3,
        },
        {
          label: 'Threshold ($4000)',
          data: thresholdData,
          borderColor: 'red',
          borderDash: [5, 5],
          fill: false,
        },
      ],
    },
    options: {
      scales: {
        y: {
          beginAtZero: false,
          ticks: {
            color: getComputedStyle(document.body).color,
          },
        },
        x: {
          ticks: {
            color: getComputedStyle(document.body).color,
          },
        },
      },
      plugins: {
        legend: {
          labels: {
            color: getComputedStyle(document.body).color,
          },
        },
      },
    },
  });
}

function updateChartColors() {
  if (chart) {
    const color = getComputedStyle(document.body).color;
    chart.options.plugins.legend.labels.color = color;
    chart.options.scales.x.ticks.color = color;
    chart.options.scales.y.ticks.color = color;
    chart.update();
  }
}

// Update page based on current price
async function updatePage() {
  const price = await fetchPrice();
  document.getElementById('price').textContent = 'Current price: $' + price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  const emojiEl = document.getElementById('emoji');
  const headerEl = document.getElementById('header');
  if (price >= happyThreshold) {
    emojiEl.textContent = 'ðŸ¥³';
    headerEl.textContent = 'ETH is above $4,000!';
    document.body.classList.add('happy');
    launchConfetti();
  } else {
    emojiEl.textContent = 'ðŸ˜¢';
    headerEl.textContent = 'ETH is below $4,000';
    document.body.classList.remove('happy');
  }
  updateChartColors();
}

// Launch confetti when price is above threshold
function launchConfetti() {
  const myConfetti = confetti.create(document.getElementById('confetti-canvas'), { resize: true, useWorker: true });
  myConfetti({
    particleCount: 200,
    spread: 90,
    origin: { y: 0.6 },
  });
}

// Initialize page
async function init() {
  const prices = await fetchChartData();
  drawChart(prices);
  document.getElementById('chart-container').style.display = 'block';
  updatePage();
}
init();
// Refresh price every minute
setInterval(updatePage, 60000);

// Set the left-side message (CRUU style)
const leftMessage = `THIS IS WHAT YOU WANTED RIGHT<br>BUT YOU'RE NOT HERE YET<br>SO WHAT HAPPENS<br>WHEN IT HITS 4K<br>SOMETHING MAGICAL`;
document.getElementById('left-message').innerHTML = leftMessage;

// Build Wordle board
const wordleContainer = document.getElementById('wordle');
for (let r = 0; r < 6; r++) {
  const rowDiv = document.createElement('div');
  rowDiv.className = 'wordle-row';
  for (let c = 0; c < 5; c++) {
    const tile = document.createElement('div');
    tile.className = 'wordle-tile';
    rowDiv.appendChild(tile);
  }
  wordleContainer.appendChild(rowDiv);
}

// Wordle game logic
const targetWord = 'HAVEN';
let currentRow = 0;
let currentTile = 0;
const guesses = Array(6).fill('');
document.addEventListener('keydown', function(event) {
  const rows = wordleContainer.children;
  if (event.key === 'Backspace') {
    if (currentTile > 0) {
      currentTile--;
      guesses[currentRow] = guesses[currentRow].slice(0, -1);
      const tile = rows[currentRow].children[currentTile];
      tile.textContent = '';
      tile.style = '';
    }
  } else if (event.key === 'Enter') {
    if (currentTile === 5) {
      evaluateGuess();
    }
  } else if (/^[a-zA-Z]$/.test(event.key)) {
    if (currentTile < 5) {
      const letter = event.key.toUpperCase();
      guesses[currentRow] += letter;
      const tile = rows[currentRow].children[currentTile];
      tile.textContent = letter;
      currentTile++;
    }
  }
});

function evaluateGuess() {
  const guess = guesses[currentRow];
  const rowTiles = wordleContainer.children[currentRow].children;
  // Count letters in target word
  const letterCount = {};
  for (const ch of targetWord) {
    letterCount[ch] = (letterCount[ch] || 0) + 1;
  }
  const statuses = Array(5).fill('absent');
  // First pass: correct positions
  for (let i = 0; i < 5; i++) {
    if (guess[i] === targetWord[i]) {
      statuses[i] = 'correct';
      letterCount[guess[i]]--;
    }
  }
  // Second pass: present letters
  for (let i = 0; i < 5; i++) {
    if (statuses[i] !== 'correct' && targetWord.includes(guess[i]) && letterCount[guess[i]] > 0) {
      statuses[i] = 'present';
      letterCount[guess[i]]--;
    }
  }
  // Apply colors based on statuses
  for (let i = 0; i < 5; i++) {
    const tile = rowTiles[i];
    if (statuses[i] === 'correct') {
      tile.style.background = '#538d4e';
      tile.style.borderColor = '#538d4e';
      tile.style.color = '#fff';
    } else if (statuses[i] === 'present') {
      tile.style.background = '#b59f3b';
      tile.style.borderColor = '#b59f3b';
      tile.style.color = '#fff';
    } else {
      tile.style.background = '#3a3a3c';
      tile.style.borderColor = '#3a3a3c';
      tile.style.color = '#fff';
    }
  }
  if (guess === targetWord) {
    setTimeout(() => alert('Congratulations! You guessed the word!'), 100);
    document.removeEventListener('keydown', arguments.callee);
  } else {
    currentRow++;
    currentTile = 0;
    if (currentRow >= 6) {
      setTimeout(() => alert('Game over! The word was ' + targetWord), 100);
      document.removeEventListener('keydown', arguments.callee);
    }
  }
}
</script>
</body>
</html>
